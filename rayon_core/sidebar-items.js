initSidebarItems({"fn":[["current_num_threads","Returns the number of threads in the current registry. If this code is executing within the Rayon thread-pool, then this will be the number of threads for the current thread-pool. Otherwise, it will be the number of threads for the global thread-pool."],["dump_stats","This is a debugging API not really intended for end users. It will dump some performance statistics out using `println`."],["initialize","Initializes the global thread pool. This initialization is **optional**.  If you do not call this function, the thread pool will be automatically initialized with the default configuration. In fact, calling `initialize` is not recommended, except for in two scenarios:"],["join","The `join` function takes two closures and *potentially* runs them in parallel. It returns a pair of the results from those closures."],["scope","Create a \"fork-join\" scope `s` and invokes the closure with a reference to `s`. This closure can then spawn asynchronous tasks into `s`. Those tasks may run asynchronously with respect to the closure; they may themselves spawn additional tasks into `s`. When the closure returns, it will block until all tasks that have been spawned into `s` complete."],["spawn_async","Fires off a task into the Rayon threadpool that will run asynchronously. As this task runs asynchronously, it cannot hold any references to the enclosing stack frame. Like a regular Rust thread, it should always be created with a `move` closure and should not hold any references (except for `&'static` references)."],["spawn_future_async","Spawns a future, scheduling it to execute on Rayon's threadpool. Returns a new future that can be used to poll for the result."]],"struct":[["Configuration","Contains the rayon thread pool configuration."],["RayonFuture","Represents the result of a future that has been spawned in the Rayon threadpool."],["Scope",""],["ThreadPool",""]]});